**Pachi：**一个简单的模块化围棋程序框架，在这个框架里有一个相当强劲的引擎。

## 安装

安装Pachi，只需:

make

生成的二进制程序`Pachi`是GTP客户端;使用您喜爱的围棋程序接口连接到它(例如gogui或qgo--对战平台)或使用kgsGtp将其连接到KGS(由于解析器不安全，不要让GTP接口可以直接被不信任的用户访问到)(请参见破解文件细节)

Pachi程序可以有很多参数，也可以使用特定的引擎;对于初始使用，也可以使用默认值。

请参阅下面的一些技巧。

以防您遇到编译问题(例如，在MacOS / X上构建时)或者想要改变配置，可以检查在Makefile顶部的用户可配置文档

## 引擎

默认的引擎为中国的规则，在9×9的棋盘中大约是7d KGS 段位。在19x19的棋盘(使用例如六路Intel i7)，它可以保持一个稳定的KGS 2d段位。当使用大型集群(64台机器，每台20个核心)，它的段位维持在KGS 3d～4d，并且在一场比赛中赢了周俊勋7子。

默认情况下，Pachi 目前使用的是"UCT引擎"兼有"蒙特卡罗方法与树搜索";UCB1AMAF树策略使用"RAVE方法"用于树搜索，而Moggy playout使用的3x3模板和各种战术检查的政策被用于半随机蒙特卡罗的选择。大规模的使用模板进行树搜索。

与此同时，我们不断尝试各种不同的方法和提高。Pachi 是一个活跃的研究平台，也完成了很多地方的改进。我们严格的测试一些新的属性，只有当它们能够提供一定的属性提升，才会给它设置为默认属性


## 如何运行

默认情况下，Pachi将在单个CPU内核上运行，达到1.4 gib内存，并在15秒内移动。你可以通过传递额外的命令行选项来调整这些参数:

​     `./ pachi - t _1200线程= 8,max_tree_size = 3072`

**这将使Pachi与时间设置有8个线程，占用3GiB内存(+几十个MiB作为一个常量开销)在对手的回合中思考。**

Pachi可以用一种与fuego兼容的格式来使用一本书——你可以获得它在下面这个网站
http://gnugo.baduk.org/fuegoob.htm
然后再pachi中用- f参数来使用:

```    
./ pachi - f book.dat……
```

你可能想要添加一些自定义的Pachi行到book.dat;可以从book.dat.extra文件中提取出来。如果使用默认的Fuego book，您可能想删除book.dat.bad列出的行。Pachi还可以使用一个模式数据库来提高它的播放性能。你可以访问http://pachi.or.cz/pat/来发现更多指令。

目前，没有全面的选择文件，但是你可以获得一个不错的想法通过查看在uct/uct.c的uct_state_init()函数，
-你会在那里找到UCT引擎选项的列表与描述。无论如何，通常上面的三个选项是你唯一真正想要改变的。

## DCNN支持

Pachi可以使用神经网络来支持更好的下棋策略。这使得它大约有1子的增强，并且使它玩的更厉害了。

首先，建立Pachi与DCNN的支持:

- 安装Caffe库(http://caffe.berkeleyvision.org)
只需要CPU就够了，不需要GPU,cuda或其他可选依赖关系。

- 编辑Makefile，设置DCNN = 1，将其指向安装和构建好caffe的位置。

在pachi运行的当前目录中安装dcnn文件。

Detlef Schmicker的54% dcnn可以在:

http://physik.de/CNNlast.tar.gz
里找到。
更多关于这个dcnn的信息可以在:

http://computer-go.org/pipermail/computer-go/2015-December/008324.html
里找到。

如果你想要使用一个有不同输入的网络，你必须调整dcnn.cpp来容纳它。Pachi将检查“golast19.prototxt”和“golast.trained“文件在启动时，并在出现19x19模式时使用。现在，dcnn和深度思考不能一起使用(深度思考的数据丢了)。

## 贪婪Pachi

通常，Pachi只关心输赢，而不考虑账户金额。这意味着当你快赢了的时候，它会瞎玩，然后在快输的时候放弃挣扎。

如果Pachi可以考虑点数的话，它可能会给你带来更愉快的体验，它会最大限度地提高(合理的)获胜的概率而且当要输的时候它会尽可能使自己不会失去更多的点。这可以通过使用最大化参数来实现，例如:

​    . / pachi - t _1200threads=8,maximize_score

这里提供了一种极具侵略性的贴目用法和最终结果在胜率的节点值中。Pachi也会记录分数,  即使输了(通常情况下，Pachi永远不会出现这种情况)。请注意，如果您将任何“dynkomi”参数传递给Pachi，您将重置“最大化分数”设置的值。

请注意，此模式中的Pachi可能稍弱，在判断球员的实力时，结果范围不应该进行考虑。

在比赛中，胜/输的概率可以在Pachi的“extra komi”或“xkomi”进度信息中近似估计。

## 实验和测试
除了UCT，Pachi 提供一个简单的低级引擎和一个空的蒙特卡洛树作为例子，这个蒙特卡洛树模拟（快速落子）策略都支持可拔插。默认情况下我们使用大量领域知识。

其他特殊引擎同样提供：

- 用于集群运行的“分布式”引擎，分布式的用户端应该提供所有指导
- 一个基本的“悔棋”引擎会通过快速落子策略的建议简单的执行下一步。
- 一个基本的“模板”引擎会根据以学的的模板落子
- 其他一小部分纯粹为开发而用

Pachi 可以作为一个测试对象来开发其他围棋对战平台。例如，想对战“plainest UCT”选手，需要以下命令：

`./pachi -t =5000 policy=ucb1,playout=light,prior=eqex=0,dynkomi=none,pondering=0,pass_all_alive`


这条命令会固定每次落子的时间为5000，生成节点的选择策略从 ucb1amaf到ucb1 （既，关闭了RAVE），生成落子的选择策略从heuristic-heavy moggy t到 uniformly random light，试探性的结束高于价值的节点，关闭动态贴目，在对手时间禁用思考并且保证Pachi 只有10%的活棋留在棋盘上（以避免计子争端）。

但是请注意，在这种模式下使用Pachi 并没有进行广泛的测试，所以在使用它之前，请检查它的性能。

请注意，即使在“基础UCT”模式下，Pachi也会根据初始状态下棋盘的对称性来优化搜索树。目前，还没有任何一种简单的操作能够关闭这一功能。有一个简单的方法是通过更改客户端的棋盘下的board_symmetry_update()使其在开始时转向(goto)break_symmetry和 ，和board_clear然后从新设置默认值board->symmetry.type = SYM_NONE.


## 分析
Pachi 可以帮助你分析你的局势，并且能够在不同的位置上提供它自己的判断。虽然用户界面非常简陋, 但确实存在这个能力。

目前有几个为 Pachi 提供此功能的接口。

__胜率发展__

----

Pachi 可以对特定游戏内的所有落子做出评估，并且可以动态的计算出双方玩家的胜率--即谁可以在哪个阶段赢得游戏，该功能由``tools/sgf-analyse.pl``这个脚本实现。

详细用法可以查阅本脚本上方注释

__落子优先级__

---

Pachi 可以评估在当前局势下所有可能的落子位置，并且在每个位置给定一个0～1的值代表如果棋子下在这个位置赢的概率。
就是说，它可以表明在给定的局势下哪次落子是好棋，哪次是臭棋。

为了实现后者，记录（指出）在给定局势下落子的数目需要运行`tools/sgf-ratemove.sh`（ratemove-值得落子的地方）这个脚本。

详细用法可以查阅本脚本上方注释

__更优的模板落子__

---

Pachi 可以非常快速的识别基于模板的落子，就像没有图形界面的Moyo Go Studio一样（一个知名的围棋软件）。你可以在落子优先级的方法之上使用这种方法``tools/sgf-ratemove.sh``（ratemove-迅速落子）,但是需要加一个额外的参数`-e patternplay`。

## 框架
该软件框架的目的是使你方便的设置基本的引擎架构，实现你的想法而减少GTP（资源）的开销，优化生成棋局速度，等等。而且已经预先设计好随机数和UTC树引擎，这样你就可以只对特定的策略进行直接调整。这个架构足够迅速并且很容易在我们的引擎上实现扩展。

想更详细的了解Pachi 开发者的观点可以阅读破解文件。

并且如果你对Pachi 的原理、结构，算法等等感兴趣的话可以阅读Petr Baudis硕士的论文：

http://pasky.or.cz/go/prace.pdf

或者一篇稍新一点的论文:

http://pasky.or.cz/go/pachi-tr.pdf













